#include <cassert>
#include <chrono>
#include <cstring>
#include <fstream>
#include <iostream>
#include <random>
#include <sstream>
#include <unordered_map>
#include <unordered_set>
#include <vector>

#include "cuckoo.h"
#include "dynamic_resizing_with_linear_probing.h"
#include "elastic.h"
#include "fixed_list_chain.h"
#include "indexed_partition_hash_with_btree.h"
#include "perfect_hashing.h"

using namespace std;
using namespace std::chrono;

template <typename K, typename V>
vector<pair<K, V>> generate_dataset(size_t count, uint64_t range);

template <>
vector<pair<uint64_t, uint64_t>> generate_dataset<uint64_t, uint64_t>(
    size_t count, uint64_t range) {
    vector<pair<uint64_t, uint64_t>> dataset;
    unordered_set<uint64_t> used;
    mt19937_64 rng(42);
    uniform_int_distribution<uint64_t> dist(1, range);

    while (dataset.size() < count) {
        uint64_t key = dist(rng);
        if (used.insert(key).second) {
            dataset.emplace_back(key, key * 10);
        }
    }
    return dataset;
}

template <>
vector<pair<string, string>> generate_dataset<string, string>(size_t count,
                                                              uint64_t range) {
    vector<pair<string, string>> dataset;
    unordered_set<string> used;
    mt19937_64 rng(42);
    uniform_int_distribution<uint64_t> dist(1, range);
    while (dataset.size() < count) {
        string key = "key" + to_string(dist(rng));
        if (used.insert(key).second) {
            string val = "val" + to_string(dist(rng));
            dataset.emplace_back(key, val);
        }
    }
    return dataset;
}

template <typename HashTable, typename DataSet>
long long benchmark_insert(HashTable& table, DataSet& dataset) {
    auto start = high_resolution_clock::now();
    for (const auto& [k, v] : dataset) {
        table.insert(k, v);
    }
    auto end = high_resolution_clock::now();
    return duration_cast<milliseconds>(end - start).count();
}

template <typename HashTable, typename DataSet>
long long benchmark_lookup(HashTable& table, DataSet& dataset) {
    auto start = high_resolution_clock::now();
    for (const auto& [k, _] : dataset) {
        auto val = table.lookup(k);
        assert(val.has_value() && val.value() == k * 10);
    }
    auto end = high_resolution_clock::now();
    return duration_cast<milliseconds>(end - start).count();
}

template <typename HashTable, typename DataSet>
long long benchmark_update(HashTable& table, DataSet& dataset) {
    auto start = high_resolution_clock::now();
    for (const auto& [k, v] : dataset) {
        table.update(k, v + 1);
    }
    auto end = high_resolution_clock::now();
    return duration_cast<milliseconds>(end - start).count();
}

template <typename HashTable, typename DataSet>
long long benchmark_delete(HashTable& table, DataSet& dataset) {
    auto start = high_resolution_clock::now();
    for (const auto& [k, _] : dataset) {
        table.remove(k);
    }
    auto end = high_resolution_clock::now();
    return duration_cast<milliseconds>(end - start).count();
}

template <typename DataSet>
long long baseline_lookup(unordered_map<uint64_t, uint64_t>& table,
                          DataSet& dataset) {
    auto start = high_resolution_clock::now();
    for (const auto& [k, _] : dataset) {
        auto val = table.find(k);
        assert(val != table.end() && val->second == k * 10);
    }
    auto end = high_resolution_clock::now();
    return duration_cast<milliseconds>(end - start).count();
}

template <typename DataSet>
long long baseline_insert(unordered_map<uint64_t, uint64_t>& table,
                          DataSet& dataset) {
    auto start = high_resolution_clock::now();
    for (const auto& [k, v] : dataset) table[k] = v;
    auto end = high_resolution_clock::now();
    return duration_cast<milliseconds>(end - start).count();
}

template <typename DataSet>
long long baseline_update(unordered_map<uint64_t, uint64_t>& table,
                          DataSet& dataset) {
    auto start = high_resolution_clock::now();
    for (const auto& [k, v] : dataset) {
        table[k] = v + 1;
    }
    auto end = high_resolution_clock::now();
    return duration_cast<milliseconds>(end - start).count();
}

template <typename DataSet>
long long baseline_delete(unordered_map<uint64_t, uint64_t>& table,
                          DataSet& dataset) {
    auto start = high_resolution_clock::now();
    for (const auto& [k, _] : dataset) {
        table.erase(k);
    }
    auto end = high_resolution_clock::now();
    return duration_cast<milliseconds>(end - start).count();
}

template <typename HashTable, typename DataSet>
void run_single_benchmark(HashTable& hashtable, DataSet& dataset,
                          ofstream& of) {
    auto test_table = [&](const string& name) {
        long long insert_time = benchmark_insert(table, dataset);
        long long lookup_time = benchmark_lookup(table, dataset);
        long long update_time = benchmark_update(table, dataset);
        long long delete_time = benchmark_delete(table, dataset);
        cout << "[" << name << "]\n"
             << "Insert time: " << insert_time << " ms\n"
             << "Lookup time: " << lookup_time << " ms\n"
             << "Update time: " << update_time << " ms\n"
             << "Delete time: " << delete_time << " ms\n";
        of << "[" << name << "]\n"
           << "Insert time: " << insert_time << " ms\n"
           << "Lookup time: " << lookup_time << " ms\n"
           << "Update time: " << update_time << " ms\n"
           << "Delete time: " << delete_time << " ms\n";
    };

    if (hashtable == "unordered_map") {
        unordered_map<uint64_t, uint64_t> baseline;
        long long insert_time = baseline_insert(baseline, dataset);
        long long lookup_time = baseline_lookup(baseline, dataset);
        long long update_time = baseline_update(baseline, dataset);
        long long delete_time = baseline_delete(baseline, dataset);
        cout << "[unordered_map]\n"
             << "Insert time: " << insert_time << " ms\n"
             << "Lookup time: " << lookup_time << " ms\n"
             << "Update time: " << update_time << " ms\n"
             << "Delete time: " << delete_time << " ms\n";
        of << "[unordered_map]\n"
           << "Insert time: " << insert_time << " ms\n"
           << "Lookup time: " << lookup_time << " ms\n"
           << "Update time: " << update_time << " ms\n"
           << "Delete time: " << delete_time << " ms\n";
    } else if (hashtable == "dynamic") {
        test_table(t, "DynamicResizeWithLinearProb");
    } else if (hashtable == "fixed") {
        FixedListChainedHashTable<uint64_t, uint64_t> t(table_capacity);
        test_table(t, "FixedListChain");
    } else if (hashtable == "perfect") {
        PerfectHash<uint64_t, uint64_t> t(table_capacity);
        test_table(t, "PerfectHashing");
    } else if (hashtable == "partition") {
        IndexedPartitionHashWithBTree<uint64_t, uint64_t> t(table_capacity);
        test_table(t, "IndexedPartitionHashWithBTree");
    } else if (hashtable == "cuckoo") {
        CuckooHash<uint64_t, uint64_t> t(table_capacity);
        test_table(t, "CuckooHash");
    } else if (hashtable == "elastic") {
        ElasticHash<uint64_t, uint64_t> t(table_capacity);
        test_table(t, "ElasticHash");
    } else {
        cerr << "Unsupported hashtable: " << hashtable << endl;
        exit(1);
    }
}

int main(int argc, char* argv[]) {
    size_t table_capacity = 1e5;
    double load_factor = 1.0;
    string type = "number";
    string hashtable = "unordered_map";

    auto print_help = []() {
        cout << "Usage: ./bin/eval_time [--capacity <int>] [--load <float>] "
                "[--hashtable <string>]\n"
             << "Options:\n"
             << "  --capacity <int>   Table capacity (default: 1e5)\n"
             << "  --load <float>     Load factor in (0, 1] (default: 1.0)\n"
             << "  --type <string>    number, string, float (default: number)\n"
             << "  --hashtable <string>    Hash table to test. Options:\n"
             << "                     unordered_map, dynamic, fixed,\n"
             << "                     perfect, partition, cuckoo, elastic, "
                "funnel\n"
             << "  --help             Show this help message\n";
    };

    for (int i = 1; i < argc; ++i) {
        if (strcmp(argv[i], "--help") == 0) {
            print_help();
            return 0;
        } else if (strcmp(argv[i], "--capacity") == 0 && i + 1 < argc) {
            table_capacity = static_cast<size_t>(stod(argv[++i]));
        } else if (strcmp(argv[i], "--load") == 0 && i + 1 < argc) {
            load_factor = stod(argv[++i]);
            if (load_factor <= 0.0 || load_factor > 1.0) {
                cerr << "Error: load factor must be in (0, 1].\n";
                return 1;
            }
        } else if (strcmp(argv[i], "--type") == 0 && i + 1 < argc) {
            type = argv[++i];
        } else if (strcmp(argv[i], "--hashtable") == 0 && i + 1 < argc) {
            hashtable = argv[++i];
        } else {
            cerr << "Unknown or incomplete argument: " << argv[i] << endl;
            return 1;
        }
    }
    std::ostringstream filename;
    filename << "./output/time_" << hashtable << "_" << type << "_"
             << table_capacity << "_" << load_factor << ".txt";
    std::ofstream out_file(filename.str());

    size_t num_keys = static_cast<size_t>(load_factor * table_capacity);
    uint64_t key_range = 1e8;

    cout << "=== Benchmark Configuration: hashtable=" << hashtable
         << ", type=" << type << ", capacity=" << table_capacity
         << ", load_factor=" << load_factor
         << ", num_keys=" << static_cast<size_t>(load_factor * table_capacity)
         << " ===\n\n";

    out_file << "=== Benchmark Configuration: hashtable=" << hashtable
             << ", type=" << type << ", capacity=" << table_capacity
             << ", load_factor=" << load_factor << ", num_keys="
             << static_cast<size_t>(load_factor * table_capacity) << " ===\n\n";

    if (type == "number") {
        vector<pair<uint64_t, uint64_t>> dataset =
            generate_dataset<uint64_t, uint64_t>(num_keys, key_range);
        
    } 
    return 0;
}
